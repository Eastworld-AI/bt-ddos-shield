import asyncio
from dataclasses import dataclass

import bittensor
import bittensor_wallet
from bittensor.core.metagraph import Metagraph
from bt_ddos_shield.event_processor import PrintingMinerShieldEventProcessor
from typing import Optional

from bt_ddos_shield.blockchain_manager import (
    AbstractBlockchainManager,
    BittensorBlockchainManager,
)
from bt_ddos_shield.encryption_manager import ECIESEncryptionManager
from bt_ddos_shield.manifest_manager import (
    JsonManifestSerializer,
    Manifest,
    ReadOnlyManifestManager,
)
from bt_ddos_shield.utils import Hotkey, PrivateKey


@dataclass
class ShieldMetagraphOptions:
    retry_delay_sec: int = 10
    """ Time in seconds to wait before retrying fetching miner address. """


class ShieldMetagraph(Metagraph):
    """
    Wrapper class for Metagraph. It allows Validator to retrieve addresses generated by MinerShield instead of Miners
    addresses presented in original metagraph. If given Miner is not shielded, it will return their original address.

    To use this class in your code just replace your Metagraph instance with ShieldMetagraph instance.
    ShieldMetagraphFactory can be used for this.
    """

    wallet: bittensor_wallet.Wallet
    """ Validator's wallet. """
    private_key: PrivateKey
    """ Private key used to decipher addresses generated for Validator by Miners. """
    blockchain_manager: AbstractBlockchainManager
    manifest_manager: ReadOnlyManifestManager
    options: ShieldMetagraphOptions

    def __init__(
            self,
            wallet: bittensor_wallet.Wallet,
            private_key: PrivateKey,
            options: ShieldMetagraphOptions,
            netuid: int,
            network: Optional[str] = None,
            lite: bool = True,
            sync: bool = True,
            subtensor: Optional[bittensor.Subtensor] = None,
            blockchain_manager: Optional[AbstractBlockchainManager] = None,
            manifest_manager: Optional[ReadOnlyManifestManager] = None,
    ):
        super().__init__(
            netuid=netuid,
            lite=lite,
            sync=sync,
            subtensor=subtensor,
            **({"network": network} if network is not None else {})
        )

        self.wallet = wallet
        self.private_key = private_key
        self.options = options
        self.blockchain_manager = blockchain_manager or self.create_default_blockchain_manager(subtensor, netuid,
                                                                                               wallet)
        self.manifest_manager = manifest_manager or self.create_default_manifest_manager()

    @classmethod
    def create_default_manifest_manager(cls) -> ReadOnlyManifestManager:
        return ReadOnlyManifestManager(JsonManifestSerializer(), ECIESEncryptionManager())

    @classmethod
    def create_default_blockchain_manager(
            cls,
            subtensor: bittensor.Subtensor,
            netuid: int,
            wallet: bittensor_wallet.Wallet,
    ) -> AbstractBlockchainManager:
        return BittensorBlockchainManager(
            subtensor=subtensor,
            netuid=netuid,
            wallet=wallet,
            event_processor=PrintingMinerShieldEventProcessor(),
        )

    async def fetch_miner_address(self, miner_hotkey: Hotkey) -> str:
        while True:
            miner_manifest_url: Optional[str] = self.blockchain_manager.get_manifest_url(miner_hotkey)
            if miner_manifest_url is not None:
                break

            await asyncio.sleep(self.options.retry_delay_sec)

        manifest: Manifest = self.manifest_manager.get_manifest(miner_manifest_url)
        url: str = self.manifest_manager.get_address_for_validator(manifest, self.wallet.hotkey.ss58_address,
                                                                   self.private_key)
        return url


class ShieldMetagraphFactory:
    """
    Factory class to create ShieldMetagraph instance. When user wants to use ShieldMetagraph instead of normal
    Metagraph they should replace in their code creation of Metagraph, which probably looks like this:
    subtensor.metagraph(...)
    with:
    ShieldMetagraphFactory.metagraph(new shield metagraph params, subtensor, ...)
    """

    @classmethod
    def metagraph(
            cls,
            wallet: bittensor_wallet.Wallet,
            private_key: PrivateKey,
            subtensor: bittensor.Subtensor,
            netuid: int,
            lite: bool = True,
            block: Optional[int] = None,
            blockchain_manager: Optional[AbstractBlockchainManager] = None,
            manifest_manager: Optional[ReadOnlyManifestManager] = None,
    ) -> ShieldMetagraph:
        """
        This method is copy of subtensor.metagraph method, but creates ShieldMetagraph instead of basic Metagraph.
        """
        metagraph = ShieldMetagraph(
            wallet=wallet,
            private_key=private_key,
            options=ShieldMetagraphOptions(),
            network=subtensor.chain_endpoint,
            netuid=netuid,
            lite=lite,
            sync=False,
            subtensor=subtensor,
            blockchain_manager=blockchain_manager,
            manifest_manager=manifest_manager,
        )
        metagraph.sync(block=block, lite=lite, subtensor=subtensor)
        return metagraph
