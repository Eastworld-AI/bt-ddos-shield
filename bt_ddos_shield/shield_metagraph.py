import asyncio
import inspect
from dataclasses import dataclass

import bittensor
import bittensor_wallet
from bittensor.core.metagraph import Metagraph
from bt_ddos_shield.event_processor import PrintingMinerShieldEventProcessor, AbstractMinerShieldEventProcessor
from typing import Optional

from bt_ddos_shield.blockchain_manager import (
    AbstractBlockchainManager,
    BittensorBlockchainManager,
)
from bt_ddos_shield.encryption_manager import AbstractEncryptionManager, ECIESEncryptionManager
from bt_ddos_shield.manifest_manager import (
    AbstractManifestSerializer,
    JsonManifestSerializer,
    Manifest,
    ReadOnlyManifestManager,
)
from bt_ddos_shield.utils import Hotkey, PrivateKey


@dataclass
class ShieldMetagraphOptions:
    retry_delay_sec: int = 10
    """ Time in seconds to wait before retrying fetching miner address. """


class ShieldMetagraph(Metagraph):
    """
    Wrapper class for Metagraph. It allows Validator to retrieve addresses generated by MinerShield instead of Miners
    addresses presented in original metagraph. If given Miner is not shielded, it will return his original address.

    To use this class in your code just replace your Metagraph instance with ShieldMetagraph instance.
    ShieldMetagraphFactory can be used for this.
    """

    wallet: bittensor_wallet.Wallet
    """ Validator's wallet. """
    private_key: PrivateKey
    """ Private key used to decipher addresses generated for Validator by Miners. """
    blockchain_manager: AbstractBlockchainManager
    manifest_manager: ReadOnlyManifestManager
    options: ShieldMetagraphOptions

    def __init__(
            self,
            wallet: bittensor_wallet.Wallet,
            private_key: PrivateKey,
            blockchain_manager: AbstractBlockchainManager,
            manifest_manager: ReadOnlyManifestManager,
            options: ShieldMetagraphOptions,
            netuid: int,
            network: Optional[str] = None,
            lite: bool = True,
            sync: bool = True,
            subtensor: Optional[bittensor.Subtensor] = None,
    ):
        # Default value for network param is settings.DEFAULT_NETWORK, but this value is not available outside library.
        sig = inspect.signature(super().__init__)
        if network is None:
            network = sig.parameters['network'].default
        super().__init__(netuid, network, lite, sync, subtensor)

        self.wallet = wallet
        self.private_key = private_key
        self.blockchain_manager = blockchain_manager
        self.manifest_manager = manifest_manager
        self.options = options

    async def fetch_miner_address(self, miner_hotkey: Hotkey) -> str:
        while True:
            miner_manifest_url: Optional[str] = self.blockchain_manager.get_manifest_url(miner_hotkey)
            if miner_manifest_url is not None:
                break

            await asyncio.sleep(self.options.retry_delay_sec)

        manifest: Manifest = self.manifest_manager.get_manifest(miner_manifest_url)
        url: str = self.manifest_manager.get_address_for_validator(manifest, self.wallet.hotkey.ss58_address,
                                                                   self.private_key)
        return url


class ShieldMetagraphFactory:
    """
    Factory class to create ShieldMetagraph instance. When user wants to use ShieldMetagraph instead of normal
    Metagraph he should replace in his code creation of Metagraph, which probably looks like this:
    subtensor.metagraph(...)
    with:
    ShieldMetagraphFactory.metagraph(new shield metagraph params, subtensor, ...)
    """

    @classmethod
    def metagraph(
            cls,
            wallet: bittensor_wallet.Wallet,
            private_key: PrivateKey,
            subtensor: bittensor.Subtensor,
            netuid: int,
            lite: bool = True,
            block: Optional[int] = None,
    ) -> ShieldMetagraph:
        """
        This method is copy of subtensor.metagraph method, but creates ShieldMetagraph instead of basic Metagraph.
        """
        event_processor: AbstractMinerShieldEventProcessor = cls.create_event_processor()
        encryption_manager: AbstractEncryptionManager = cls.create_encryption_manager()
        manifest_manager: ReadOnlyManifestManager = cls.create_manifest_manager(encryption_manager)
        blockchain_manager: AbstractBlockchainManager = cls.create_blockchain_manager(subtensor, netuid, wallet,
                                                                                      event_processor)
        metagraph = ShieldMetagraph(
            wallet=wallet,
            private_key=private_key,
            blockchain_manager=blockchain_manager,
            manifest_manager=manifest_manager,
            options=ShieldMetagraphOptions(),
            network=subtensor.chain_endpoint,
            netuid=netuid,
            lite=lite,
            sync=False,
            subtensor=subtensor,
        )
        metagraph.sync(block=block, lite=lite, subtensor=subtensor)
        return metagraph

    @classmethod
    def create_event_processor(cls) -> AbstractMinerShieldEventProcessor:
        return PrintingMinerShieldEventProcessor()

    @classmethod
    def create_encryption_manager(cls) -> AbstractEncryptionManager:
        return ECIESEncryptionManager()

    @classmethod
    def create_manifest_manager(cls, encryption_manager: AbstractEncryptionManager) -> ReadOnlyManifestManager:
        manifest_serializer: AbstractManifestSerializer = JsonManifestSerializer()
        return ReadOnlyManifestManager(manifest_serializer, encryption_manager)

    @classmethod
    def create_blockchain_manager(
            cls,
            subtensor: bittensor.Subtensor,
            netuid: int,
            wallet: bittensor_wallet.Wallet,
            event_processor: AbstractMinerShieldEventProcessor,
    ) -> AbstractBlockchainManager:
        return BittensorBlockchainManager(
            subtensor=subtensor,
            netuid=netuid,
            wallet=wallet,
            event_processor=event_processor
        )
