from dataclasses import dataclass

import bittensor
import bittensor_wallet
from bittensor.core.metagraph import Metagraph
from bt_ddos_shield.event_processor import PrintingMinerShieldEventProcessor
from typing import Optional, Dict

from bt_ddos_shield.blockchain_manager import (
    AbstractBlockchainManager,
    BittensorBlockchainManager,
)
from bt_ddos_shield.encryption_manager import ECIESEncryptionManager
from bt_ddos_shield.manifest_manager import (
    JsonManifestSerializer,
    Manifest,
    ReadOnlyManifestManager,
)
from bt_ddos_shield.utils import Hotkey, PrivateKey


@dataclass
class ShieldMetagraphOptions:
    retry_delay_sec: int = 10
    """ Time in seconds to wait before retrying fetching miner address. """


class ShieldMetagraph(Metagraph):
    """
    Wrapper class for Metagraph. It allows Validator to retrieve addresses generated by MinerShield instead of Miners
    addresses presented in original metagraph. If given Miner is not shielded, it will return their original address.

    To use this class in your code just replace your Metagraph instance with ShieldMetagraph instance. If you were
    using subtensor.metagraph() before, you should now use constructor with sync param set to True and other params
    set appropriately.
    """

    wallet: bittensor_wallet.Wallet
    """ Validator's wallet. """
    private_key: PrivateKey
    """ Private key used to decipher addresses generated for Validator by Miners. """
    blockchain_manager: AbstractBlockchainManager
    manifest_manager: ReadOnlyManifestManager
    options: ShieldMetagraphOptions

    def __init__(
            self,
            wallet: bittensor_wallet.Wallet,
            private_key: PrivateKey,
            netuid: int,
            network: Optional[str] = None,
            lite: bool = True,
            sync: bool = True,
            block: Optional[int] = None,
            subtensor: Optional[bittensor.Subtensor] = None,
            blockchain_manager: Optional[AbstractBlockchainManager] = None,
            manifest_manager: Optional[ReadOnlyManifestManager] = None,
            options: ShieldMetagraphOptions = ShieldMetagraphOptions(),
    ):
        super().__init__(
            netuid=netuid,
            lite=lite,
            sync=False,
            subtensor=subtensor,
            **({'network': network} if network is not None else {})
        )

        self.wallet = wallet
        self.private_key = private_key
        self.options = options
        self.blockchain_manager = blockchain_manager or self.create_default_blockchain_manager(subtensor, netuid,
                                                                                               wallet)
        self.manifest_manager = manifest_manager or self.create_default_manifest_manager()

        if sync:
            self.sync(block=block, lite=lite, subtensor=subtensor)
        elif block is not None:
            raise ValueError('Block argument is valid only when sync is True')

    @classmethod
    def create_default_manifest_manager(cls) -> ReadOnlyManifestManager:
        return ReadOnlyManifestManager(JsonManifestSerializer(), ECIESEncryptionManager())

    @classmethod
    def create_default_blockchain_manager(
            cls,
            subtensor: bittensor.Subtensor,
            netuid: int,
            wallet: bittensor_wallet.Wallet,
    ) -> AbstractBlockchainManager:
        return BittensorBlockchainManager(
            subtensor=subtensor,
            netuid=netuid,
            wallet=wallet,
            event_processor=PrintingMinerShieldEventProcessor(),
        )

    async def fetch_miner_address(self, miner_hotkey: Hotkey) -> Optional[str]:
        miner_manifest_urls: Dict[Hotkey, Optional[str]] = \
            await self.blockchain_manager.get_manifest_urls([miner_hotkey])
        miner_manifest_url: Optional[str] = miner_manifest_urls.get(miner_hotkey)
        if miner_manifest_url is None:
            return None

        manifests: Dict[Hotkey, Optional[Manifest]] = await self.manifest_manager.get_manifests(miner_manifest_urls)
        manifest: Optional[Manifest] = manifests.get(miner_hotkey)
        if manifest is None:
            return None
        url: str = self.manifest_manager.get_address_for_validator(manifest, self.wallet.hotkey.ss58_address,
                                                                   self.private_key)
        return url
