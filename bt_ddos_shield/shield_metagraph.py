import asyncio
from dataclasses import dataclass

import bittensor
import bittensor_wallet
from bittensor.core.metagraph import Metagraph
from bt_ddos_shield.event_processor import AbstractMinerShieldEventProcessor, PrintingMinerShieldEventProcessor
from typing import Optional, Dict

from bt_ddos_shield.blockchain_manager import (
    AbstractBlockchainManager,
    BittensorBlockchainManager,
)
from bt_ddos_shield.encryption_manager import ECIESEncryptionManager
from bt_ddos_shield.manifest_manager import (
    JsonManifestSerializer,
    Manifest,
    ManifestDeserializationException,
    ReadOnlyManifestManager,
)
from bt_ddos_shield.utils import Hotkey, PrivateKey


@dataclass
class ShieldMetagraphOptions:
    replace_ip_address_for_axon: bool = True
    """
    Determines how shield address is added to axon info in metagraph. If True, shield address will replace original one
    in `ip` field, otherwise new field `shield_address` will be added. In both cases, port will be replaced with port
    from shield.
    """


class ShieldMetagraph(Metagraph):
    """
    Wrapper class for Metagraph. It allows Validator to retrieve addresses generated by MinerShield instead of Miners
    addresses presented in original metagraph. If given Miner is not shielded, it will return their original address.

    To use this class in your code just replace your Metagraph instance with ShieldMetagraph instance. If you were
    using subtensor.metagraph() before, you should now use constructor with sync param set to True and other params
    set appropriately.
    """

    wallet: bittensor_wallet.Wallet
    """ Validator's wallet. """
    private_key: PrivateKey
    """ Private key used to decipher addresses generated for Validator by Miners. """
    event_processor: AbstractMinerShieldEventProcessor
    blockchain_manager: AbstractBlockchainManager
    manifest_manager: ReadOnlyManifestManager
    options: ShieldMetagraphOptions

    def __init__(
            self,
            wallet: bittensor_wallet.Wallet,
            private_key: PrivateKey,
            netuid: int,
            network: Optional[str] = None,
            lite: bool = True,
            sync: bool = True,
            block: Optional[int] = None,
            subtensor: Optional[bittensor.Subtensor] = None,
            event_processor: Optional[AbstractMinerShieldEventProcessor] = None,
            blockchain_manager: Optional[AbstractBlockchainManager] = None,
            manifest_manager: Optional[ReadOnlyManifestManager] = None,
            options: ShieldMetagraphOptions = ShieldMetagraphOptions(),
    ):
        super().__init__(
            netuid=netuid,
            lite=lite,
            sync=False,
            subtensor=subtensor,
            **({'network': network} if network is not None else {})
        )

        self.wallet = wallet
        self.private_key = private_key
        self.options = options
        self.event_processor = event_processor or PrintingMinerShieldEventProcessor()
        self.blockchain_manager = \
            blockchain_manager or self.create_default_blockchain_manager(subtensor, netuid, wallet,
                                                                         self.event_processor)
        self.manifest_manager = manifest_manager or self.create_default_manifest_manager(self.event_processor)

        if sync:
            self.sync(block=block, lite=lite, subtensor=subtensor)
        elif block is not None:
            raise ValueError('Block argument is valid only when sync is True')

    @classmethod
    def create_default_manifest_manager(cls,
                                        event_processor: AbstractMinerShieldEventProcessor) -> ReadOnlyManifestManager:
        return ReadOnlyManifestManager(JsonManifestSerializer(), ECIESEncryptionManager(), event_processor)

    @classmethod
    def create_default_blockchain_manager(
            cls,
            subtensor: bittensor.Subtensor,
            netuid: int,
            wallet: bittensor_wallet.Wallet,
            event_processor: AbstractMinerShieldEventProcessor,
    ) -> AbstractBlockchainManager:
        return BittensorBlockchainManager(
            subtensor=subtensor,
            netuid=netuid,
            wallet=wallet,
            event_processor=event_processor,
        )

    def sync(self, block: Optional[int] = None, lite: bool = True, subtensor: Optional[bittensor.Subtensor] = None):
        super().sync(block=block, lite=lite, subtensor=subtensor)
        hotkeys: list[str] = self.hotkeys
        urls: Dict[Hotkey, Optional[str]] = asyncio.run(self.blockchain_manager.get_manifest_urls(hotkeys))
        manifests: Dict[Hotkey, Optional[Manifest]] = asyncio.run(self.manifest_manager.get_manifests(urls))
        own_hotkey: Hotkey = Hotkey(self.wallet.hotkey.ss58_address)
        for axon in self.axons:
            manifest: Optional[Manifest] = manifests.get(axon.hotkey)
            if manifest is not None:
                try:
                    shield_address: Optional[tuple[str, int]] = \
                        self.manifest_manager.get_address_for_validator(manifest, own_hotkey, self.private_key)
                except ManifestDeserializationException as e:
                    self.event_processor.event('Error while getting shield address for miner {hotkey}',
                                               exception=e, axon=axon.hotkey)
                    continue
                if shield_address is not None:
                    if self.options.replace_ip_address_for_axon:
                        axon.ip = shield_address[0]
                    else:
                        axon.shield_address = shield_address[0]
                    axon.port = shield_address[1]
